function recurse(f, call, depth)
    f(call, depth)
    depth += 1
    map(call.children) do child
        recurse(f, child, depth)
    end
end

function recurse(f, trace::Callsite)
    recurse(f, trace, 1)
end

"""
    flatten(t::Callsite)

Helper function that flattens a trace generated by `concolic_execution` so that only the leaf nodes are present.
"""
function flatten(t::Callsite)
    stream = Tuple{Any, Any, Tuple}[]
    recurse(t) do call, _
        if isempty(call.children)
            push!(stream, (call.f, call.retval, call.args))
        end
        return
    end
    return stream
end

function filter(t::Callsite)
    stream = Tuple{Any, Any, Tuple}[]
    recurse(t) do call, _
        if isempty(call.children) && any(a->isa(a,Sym), call.args)
            if anything(call.retval) in call.args
                if call.f !== Base.convert
                    @warn """
                    Found method that assigns to an input argument
                    Skipping ($(call.f), $(call.retval), $(call.args))
                    """
                end
                return
            end
            push!(stream, (call.f, call.retval, call.args))
        end
        return
    end
    return stream
end


const FUNCTIONS_TO_IGNORE =(
    assert,
    prove,
)

"""
    verify(trace, merciless=false)

Use `verify(trace, true)` to see built-ins that cause concrete execution
"""
function verify(t::Callsite, merciless=false)
    topmost = t.f
    recurse(t) do call, depth
        if any(a->isa(a, Sym), call.args) && !isa(anything(call.retval), Sym)
            if !merciless
                typeof(call.f) <: Core.Builtin && return

                # Check if tagged is only a type variable, like in `convert(Sym{T}, x)`
                syms = (a for a in call.args if isa(a, Sym))
                all(s->s._type == DataType, syms) && return
            end

            if call.f == topmost || call.f ∈ FUNCTIONS_TO_IGNORE
                return
            end
            @warn "Function $(call.f) did not propagate taint, $((call.retval, call.args))"
        end
        return
    end
    return nothing
end

function Base.show(io::IO, t::Callsite)
    recurse(t) do call, depth
        base = "  "^depth
        write(io, base)
        print(io, call.retval)
        write(io, " ⇐ ")
        println(io, call.f, call.args)
        return
    end
    return nothing
end

function Base.show(io::IO, s::Sym)
    print(io, s.name)
end
